# [计算机位运算相关概念](https://www.cnblogs.com/1012hq/p/11548809.html)

## 1、位运算概述

现代计算机中所有的数据都是以二进制的形式存储在设备中。即 0、1 两种状态，计算机对二进制数据进行的运算（+、-、*、/）都叫做位运算，即将符号位共同参与运算的运算。

举一个简单的例子来看下 CPU 是如何进行计算的，比如这行代码：

```java
int a = 35; 
int b = 47; 
int c = a + b;
```

计算两个数的和，在计算机中都是以二进制来进行运算，所以上面我们所给的 int 变量会在机器内部先转换为二进制在进行相加：

![img](../images/1733083-20190919102220527-579931571.png)

由此可见，相比在代码中直接使用（+、-、*、/）运算符，合理的运用位运算更能显著提高代码在机器上的执行效率。

## 2、位运算概览

本文涉及的位运算符如下表格所示，关于每一个位运算的详细用法与常见面试题会在后面一一写出。

| 符号 | 描述       | 运算规则                                                     |
| ---- | ---------- | ------------------------------------------------------------ |
| &    | 与         | 两个位都为 1 时，结果才为 1                                  |
| \|   | 或         | 两个位有一个为 1 时，结果都为 1                              |
| ^    | 异或       | 两个位相同为 0，相异为 1                                     |
| ~    | 取反       | 0 变 1，1 变 0                                               |
| <<   | 左移       | 各二进位全部左移若干位，高位丢弃，低位补 0                   |
| >>   | 右移       | 各二进位全部右移若干位，对无符号数，高位补 0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补 0（逻辑右移） |
| >>>  | 无符号右移 | 无符号右移，忽略符号位，空位都以 0 补齐                      |

**按位与运算符（&）**

定义：参加运算的两个数据，按二进制位进行“与”运算。

运算规则：

```
0&0=0  0&1=0  1&0=0  1&1=1
```

总结：两位同时为 1，结果才为 1，否则结果为 0。

例如：3&5 即 0000 0011& 0000 0101 = 0000 0001，因此 3&5 的值得 1。

注意：负数按**补码**形式参加按位与运算。

**常见面试题**

1.常用来对一个数据的某些位设置为 1

比如将数 X=1010 1110 的低 4 位设置为 1，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y=0000 1111，然后将 X 与 Y 进行按位或运算（X|Y=1010 1111）即可得到。

**异或运算符（^）**

定义：参加运算的两个数据，按二进制位进行 “异或” 运算。

运算规则：

```
0^0=0  0^1=1  1^0=1  1^1=0
```

总结：参加运算的两个对象，如果两个相应位相同为 0，相异为 1。

异或运算性质:

- 交换律
- 结合律：(a^b)^c == a^(b^c)
- 对于任何数 x，都有 x^x=0，x^0=x
- 自反性：a^b^b=a^0=a

**常见面试题**

1.翻转指定位

比如将数 X=1010 1110 的低 4 位进行翻转，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y=0000 1111，然后将 X 与 Y 进行异或运算（X^Y=1010 0001）即可得到。

2.与 0 相异或值不变

例如：1010 1110 ^ 0000 0000 = 1010 1110

3.交换两个数

```c++
void Swap(int &a, int &b){ 
    if (a != b){       
        a ^= b;        
        b ^= a; //b =b^ a^b= a
        a ^= b; //a =a^b ^a= b    
    } 
}
```

4.找出单次出现的数字

给出一堆乱序数字，只有一个数字出现了一次，其余数字都出现了两次，如何找出出现一次的这个数字？

例如：1，2，2，3，3

解答：将这些数字全部异或之后结果即为这个数字（ 1^2^2^3^3 = 1）。

**取反运算符 (~)**

定义：参加运算的一个数据，按二进制进行“取反”运算。

运算规则：　

```
~1=0 
~0=1
```

总结：对一个二进制数按位取反，即将 0 变 1，1 变 0。

**常见面试题**

1.使一个数的二进制最低位为零

使 a 的最低位为 0，可以表示为：a & ~1。

~1 的值为 1111 1111 1111 1110，再按” 与” 运算，最低位一定为 0。因为“~”运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。

**左移运算符（<<）**

定义：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补 0）。

例如：设 a=1010 1110，a = a<< 2 将 a 的二进制位左移 2 位、右补 0，即得 a=1011 1000。

说明：若左移时舍弃的高位不包含 1，则每左移一位，相当于该数乘以 2。

**右移运算符（>>）**

定义：将一个数的各二进制位全部右移若干位，正数左补 0，负数左补 1，右边丢弃。

例如：a=a>>2 将 a 的二进制位右移 2 位，左补 0 或者 左补 1 得看被移数是正还是负。

说明：操作数每右移一位，相当于该数除以 2。

**无符号右移（>>>）**

在计算机中负数采用二进制的补码表示，即 10 进制转为 2 进制得到的是原码，将原码按位取反得到的是反码，反码加 1 得到补码。二进制的最高位是符号位，0 表示正，1 表示负。

\>>> 与 >> 唯一的不同是它无论原来的最左边是什么数，统统都用 0 填充。

举例：-1 的 32 进制位

```
原码 : 0000 0000 0000 0000 0000 0000 0000 0001
反码 : 1111 1111 1111 1111 1111 1111 1111 1110 
补码 : 1111 1111 1111 1111 1111 1111 1111 1111 （在反码基础上 + 1） a<<2: 1111 1111 1111 1111 1111 1111 1111 1100 
a>>2: 1111 1111 1111 1111 1111 1111 1111 1111 （右移两位，左边高位再补两个 1，所以看着没什么变化） 
a>>>2: 0011 1111 1111 1111 1111 1111 1111 1111 (无符号右移跟上个比起来就是高位不补 1）
```

**复合赋值运算符**

位运算符与赋值运算符结合，组成新的复合赋值运算符，它们是：

- &= 例：a&=b 相当于 a=a&b
- |= 例：a|=b 相当于 a=a|b
- \>>= 例：a>>=b 相当于 a=a>>b
- <<= 例：a<<=b 相当于 a=a<<b
- ^= 例：a^=b 相当于 a=a^b

不同长度的数据进行位运算

如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。

以“与运算”为例说明如下：

我们知道在 C 语言中 long 型占 4 个字节，int 型占 2 个字节，如果一个 long 型数据与一个 int 型数据进行“与运算”，右端对齐后，左边不足的位依下面三种情况补足。

1.如果整型数据为正数，左边补 16 个 0

例如：long a=123，int b=1，计算 a&b

2.如果整型数据为负数，左边补 16 个 1

例如：long a=123，int b=-1，计算 a&b

3.如果整形数据为无符号数，左边也补 16 个 0

例如：long a=123，unsigned b=1，计算 a&b

**位运算实现加乘除四则运算**

**加法**

两个二进制数异或运算的结果是不考虑进位时的结果，两个二进制数与运算的结果中含有 1 的位是有进位的位。

以 0101 + 0001 = 0110 为例分析如下：

```
//计算 0101 + 0001 
0101 ^ 0001 = 0100 //异或结果表明，如果不考虑进位，那么结果为0100 
0101 & 0001 = 0001 //与运算结果表明，最低位需要向次低位进1 
0001 << 1 = 0010   //与运算结果左移一位，将进位加到高位上 
//递归计算 0100 + 0010，直到+号右侧数字为0
```

Java 代码：

```java
//递归 
public static int add(int a, int b) {
    if (b == 0) {       
        return a;   
    } else {       
        return add(a ^ b, (a & b) << 1); 
    } 
} 
//循环 
public static int add2(int a, int b) {    
    int sum = a;   
    while (b != 0) {  
        sum = a ^ b;   
        b = (a & b) << 1; 
        a = sum;   
    }   
    return sum; 
}
```

**减法**

与加法的思路一致，只不过减去一个数等于加一个数的相反数。例如：5-1 = 5+(-1)。所以，我们只需要求出被减数的相反数即可。

如何求出一个数的相反数？

计算机中存储的是二进制的补码形式，正数的补码与原码相同，负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加 1。

例如：

- 1 在计算机中的二进制表示为：0000 0001
- -1 在计算机中的二进制表示为：1111 1111

计算过程为：

- -1 的原码：1000 0001
- -1 的反码：1111 1110
- -1 的补码：1111 1111

其中，由 1 的原码（0000 0001）取反可得 -1 的反码（1111 1110）。

总结，一个数的相反数的求法就是该数每一位取反，末位加一。

Java 代码：

```java
public static int minus(int a, int b) {
    return add(a, add(~b, 1));
}
```

**乘法**

如果没有思路，那先在纸上笔算二进制乘法的过程：

```
        0101    a
    ×   0110    b
    ----------------
        0000    
       0101   
      0101      
   + 0000       
    ----------------
     00011110
```

梳理下笔算二进制乘法的过程：

初始化乘积结果为 0，依次遍历数字 b 的末位 0→1→1→0，当末位为 0 时，乘积结果加上 0，也就是乘积不变，A 左移一位；当末位为 1 时，乘积结果加上 a，A 再左移一位。

如何遍历数字 b 的末位呢？

根据前面的知识，我们可以使用与运算取一个数的末位，并不断右移数字 b，直到数字 b==0，即可结束位移。

需要注意的是正负数的符号问题，此处是先对 a、b 两数的绝对值计算其乘积，最后再确定其符号。

Java 代码为：

```java
public static int multiply(int a, int b) {
    //将乘数和被乘数都取绝对值
    int A = a < 0 ? add(~a, 1) : a;
    int B = b < 0 ? add(~b, 1) : b;
    //计算绝对值的乘积
    int P = 0;
    while (B != 0) {
        if ((B & 1) != 0) { //取乘数的二进制的最后一位，0 or 1
            P = add(P, A);
        }
        A = A << 1;
        B = B >> 1;
    }
    //计算乘积的符号
    if ((a ^ b) < 0) {
        P = add(~P, 1);
    }
    return P;
}
```

**除法**

除法是由乘法的过程逆推而来的。例如 9÷4=2...1，也就是 2*4+1=9。假设用 9 去减 4*2，可以得出结果等于 1，因为 1 小于 4，那么就可以得出 9÷4 的商是 2，余数是 1。

如何确定 4 的倍数是逼近最终结果的关键。我们知道，int 整型有 32 位，除首位表示符号位，每一位的大小是 [2^0, 2^1, 2^2, ..., 2^30]，最大的 int 整数是 2^31-1。所以，我们可以依次将被除数与 2^31, 2^30, ..., 2^3, 2^2, 2^1, 1 相乘，如果除数大于它们的乘积，除数就与之相减，并用相减得到的余数继续作为除数，直到循环结束。

Java 代码：

```java
public static int[] divide(int a, int b) {
    // 对被除数和除数取绝对值
    int A = a < 0 ? add(~a, 1) : a;
    int B = b < 0 ? add(~b, 1) : b;

    int N = 0; // 商 N
    for (int i = 31; i >= 0; i--) {
        // 未使用A>=(B<<i)进行判断，因为只有左移B时舍弃的高位不包含1，才相当于该数乘以2的i次方.
        if ((A >> i) >= B) { // A ÷ 2^i >= B
            N += (1 << i); // N = N + 2^i
            A -= (B << i); // A = A - B*2^i
        }
    }

    int C = A; // 余数C
    // 求商的符号
    if ((a ^ b) < 0) {
        N = add(~N, 1);
    }
    // 求余数的符号
    if (a < 0) {
        C = add(~C, 1);
    }
    return new int[]{N, C};
}
```